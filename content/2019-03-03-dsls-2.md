+++
title = "DSLs II: Challenges"
date = 2019-03-03
+++

_This post is part of a series:_

- [_DSLs I: Introduction_](/dsls-1)
- _DSLs II: Challenges (current)_

---

In the last post we examined some examples of DSLs in Rust, and established that
using DSLs is a common practice.

In this post we'll look at some of the challenges around DSLs in Rust, and draw
on examples of how these have been solved in the past.

## Interpolation
Some DSLs are perfectly expressed as regular Rust. For example file paths map
well to strings. But with [variable
interpolation](https://en.wikipedia.org/wiki/String_interpolation) there are
many different flavors around:

[quote](https://docs.rs/quote/0.6.11/quote/):
```rust
let msg = "Chashu";
let tokens = quote!{
  println!("hello, {}", #msg);
}
```

[serde_json](https://docs.rs/serde_json/1.0.39/serde_json/#constructing-json-values):
```rust
let name = "Nori"
let data = json!{{
  "name": name,
  "age": 1,
});
```

[typed-html](https://docs.rs/typed-html/0.1.1/typed_html/#example-1):
```rust
let tree = html!{
  <ul>{(1..=5).map(|i| html!{
    <li>{ text!("{}", i) }</li>
  })}</ul>
};
```

All of the examples above have similar, yet slightly different syntaxes for
interpolation. And these aren't the only syntaxes in use: there is no standard
way to interpolate variables and code in Rust, which means there's no standard
way for editors and other tools to detect when this takes place.

## Compile-time Optimization
With DSLs it's often the case that the output of the DSL depends on the target.
For example with HTML, on the server we would want to render it to byte buffers,
but in the browser we would want to use it as part of a "virtual DOM".

Another thing is that DSLs often make use of custom compiler pipelines. The
language gets parsed, interpreted, and then often converted to instructions in
some form or shape.

To reduce the overhead these components provide, DSLs are often compiled during
the program's compilation step.
