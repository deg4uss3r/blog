+++
title = "WASM 2019"
date = 2019-01-13
+++

This is my post about what I'd like to see happen with [WebAssembly and Rust in
2019](https://rustwasm.github.io/2018/12/06/reflecting-on-rust-and-wasm-in-2018.html#rustwasm2019).
Yesterday I wrote about [what I plan to work on this
year](https://blog.yoshuawuyts.com/plans-for-2019/).

## Status quo
2017 has been a really cool year for WASM and Rust. Back in February the
WASM toolchain became usable. Around the same time both
[wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) and
[wasm-pack](https://github.com/rustwasm/wasm-pack) were kicked off (I remember
the dates because of [this gem](https://github.com/browserify/rustify)).

I think it's interesting to point this out, because it means that at the time of
writing Rust's defacto WASM toolchain is about 9 months old. That's not a long
time for a project that is now considered standard. It's super impressive how
much the WASM WG has accomplished last year!

I think it's very interesting to look ahead at what can be done this year.

## fn main
The narrative of the WASM WG's tooling in 2018 has mostly revolved around
allowing people building browser applications to gradually introduce Rust into
their workflows. This has been great for people looking to improve parts of
their existing JavaScript codebase.

This year I'd love for the WASM WG to make WASM an excellent experience for
Rust programmers too. I think it'll be healthy for Rust's WASM toolchain to show
what it can do when used by itself. WASM is not intended to replace JavaScript
by any means. But I do believe that the best path to showing *why* it's useful
is to allow it to shine in its own right. The path to allowing it to do so will
probably yield results that are useful for *every* workflow.

Probably a good target to get there would be to create first-class support for
WASM binaries.
For example
[`[wasm_bindgen(start)]`](https://github.com/rustwasm/wasm-bindgen/pull/1057)
can be used as an application entry point, and the resulting binaries can be
served with a static web server. But neither of them feel as nice as Rust's own
`fn main` and `cargo run`.

## Build an ecosystem
Speaking of ecosystems, we should probably build one! I don't think structuring
this too much is useful. But there's a few points I think are important:

1. __Don't create branded silos.__ Branding might perhaps be useful to achieve
   personal fame. But if we truly want Rust's WASM story to succeed we should
   think of ways to collaborate instead of carving out territory in the hope of
   personal success.
2. __Centralize discovery.__ We're trying to build an ecosystem from scratch.
   Having a place to allow module authors to share their results will likely
   allow them to loosely coordinate. A way that's likely to work is for the WASM
   WG to create an
   [awesome](https://github.com/sindresorhus/awesome/blob/master/awesome.md)
   list under the GitHub org, and liberally accepting contributions.
3. __Encourage experimentation.__ I think it's way too early in Rust's lifecycle
   to know what the right way to do things. Even more so for Rust WASM. I think
   we should encourage experimentation and sharing results early. The lower we
   can make the boundary to experiment, the likelier it is that people will get
   involved, and in turn the likelier the ecosystem will grow in both size and
   quality.

## Polish the existing flows
I wouldn't want to propose dropping everything that's going on in favor of the
points I've raised so far. I think the WASM WG's current path is very promising!

I'd love for the existing tools to keep getting polished / improved further as
things progress. To name a few things:
- `wasm-bindgen` doesn't generate source maps yet. This doesn't help with
  debugging.
- The story around async and WASM seems only partly executed so far. Rust
  Futures can be converted to JS Promises and hooked into the JS event loop, but
  running your own multi-threaded loop seems to involve a lot of manual work
  still.
- Rust WASM artifacts are single binaries which are hard to cache and
  incrementally load. There's probably exploration possible around code
  splitting and dynamically loading.
- Setting up a WASM project requires [quite some
  boilerplate](https://github.com/rustwasm/rust-webpack-template/blob/7ff65a1a463a770a5ed3c370c114a59a7629cb86/crate/src/lib.rs#L8-L28).
  It'd be nice if we could find ways to reduce this.

## Wrapping up
And that's more or less what I'd like to see from Rust WASM this year. I feel
Rust's WASM story is very much on the right patch already, and I hope this will
only keep improving in 2019.

I hope this has been useful. Thanks for reading!
